---
date: 2020-12-30T13:13:23+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "Go 编译命令执行过程以及编译相关的命令参数"  # 文章标题
url:  "posts/go/quickstart/go_build"  # 设置网页永久链接
tags: [ "go", "build" ]  # 标签
series: [ "Go 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

让人困惑的一个命令：

```shell
go build ./...
```

`./` 表示当前目录
`...` 表示递归编译全部文件

- [认识 go build](#认识-go-build)
  - [常用参数选项](#常用参数选项)
  - [命令选项演示](#命令选项演示)
- [编译器原理](#编译器原理)
  - [词法分析](#词法分析)
  - [语法分析](#语法分析)
  - [语义分析](#语义分析)
  - [中间码生成](#中间码生成)
  - [代码优化](#代码优化)
  - [机器码生成](#机器码生成)
- [编译子命令](#编译子命令)
  - [go run](#go-run)
  - [go build](#go-build)
  - [go install](#go-install)
- [编译参数](#编译参数)
- [交叉编译](#交叉编译)
  - [常用参数](#常用参数)
  - [进行交叉编译](#进行交叉编译)
  - [编译缓存](#编译缓存)
  - [缩小编译文件大小](#缩小编译文件大小)
  - [编译信息写入](#编译信息写入)

## 认识 go build

当我们敲下 `go build` 的时候，我们的写的源码文件究竟经历了哪些事情？最终变成了可执行文件。

首先先来认识以下 go 的代码源文件分类

- **命令源码文件**：简单说就是含有 main 函数的那个文件，通常一个项目一个该文件
- **测试源码文件**：就是我们写的单元测试的代码，都是以 `_test.go` 结尾
- **库源码文件**：没有上面特征的就是库源码文件，像我们使用的很多第三方包都属于这部分

`go build` 命令就是用来编译这其中的 **命令源码文件** 以及它依赖的 **库源码文件**。

### 常用参数选项

下面表格是一些常用的选项，在这里集中说明以下：

| 可选项 | 说明 |
| ------ | ------ |
| -a | 将命令源码文件与库源码文件全部重新构建，即使是最新的 |
| -n | 把编译期间涉及的命令全部打印出来，但不会真的执行，非常方便我们学习 |
| -race | 开启竞态条件的检测，支持的平台有限制 |
| -x | 打印编译期间用到的命名，它与 -n 的区别是，它不仅打印还会执行 |

### 命令选项演示

接下来就用一个 `hello world` 程序来演示以下上面的命令选项。

```go
package main

import "fmt"

func main() {
    a := 1 + 2
    b := 10

    c := a * b
    fmt.Println(c)
}
```

如果对上面的代码执行 `go build -n` 我们看一下输出信息：

![img](https://i.loli.net/2020/12/30/SzUy5flFIc1mV64.png)

来分析下整个执行过程：

![img](https://i.loli.net/2020/12/30/ZPknzfdcl3yJ1QN.png)

这一部分是编译的核心，通过 `compile`、 `buildid`、 `link` 三个命令会编译出可执行文件 `a.out`。

然后通过 `mv` 命令把 `a.out` 移动到当前文件夹下面，并改成跟项目文件一样的名字，也可以自己指定名字。

## 编译器原理

这是 go 编译器的[源码路径](https://github.com/golang/go/tree/master/src/cmd/compile)：

```url
https://github.com/golang/go/tree/master/src/cmd/compile
```

![img](https://i.loli.net/2020/12/30/9BUhtlvIE6aGJKk.png)

如上图所见，整个编译器可以分为：编译前端与编译后端；现在我们看看每个阶段编译器都做了些什么事情。先来从前端部分开始。

### 词法分析

词法分析简单来说就是将我们写的源代码翻译成 `Token`，这是个什么意思呢？

为了理解 `Golang` 从源代码翻译到 `Token` 的过程，我们用一段代码来看一下翻译的一一对应情况。

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello Golang!")
}
```

![img](https://i.loli.net/2020/12/30/3NshrnFG7a9KxqJ.png)

图中重要的地方我都进行了注释，不过这里还是有几句话多说一下，我们看着上面的代码想象以下，如果要我们自己来实现这个“翻译工作”，程序要如何识别 `Token` 呢？

首先先来给 Go 的 token 类型分个类：变量名、字面量、操作符、分隔符以及关键字。我们需要把一堆源代码按照规则进行拆分，其实就是分词，看着上面的例子代码我们可以大概制定一个规则如下：

1. 识别空格，如果是空格可以分一个词；
2. 遇到 `(` 、`)`、’<’、’>’ 等这些特殊运算符的时候算一个分词；
3. 遇到 “ 或者 数字字面量算分词。

通过上面的简单分析，其实可以看出源代码转 `Token` 其实没有非常复杂，完全可以自己写代码实现出来。当然也有很多通过正则的方式实现的比较通用的词法分析器，像 `Golang` 早期就用的是 `lex`，在后面的版本中才改用了 go 来自己实现。

### 语法分析

经过词法分析后，我们拿到的就是 `Token` 序列，它将作为语法分析器的输入。然后经过处理后生成 `AST` 结构作为输出。所谓的语法分析就是将 `Token` 转化为可识别的程序语法结构，而 `AST` 就是这个语法的抽象表示。构造这颗树有两种方法。

1. **自上而下** 这种方式会首先构造根节点，然后就开始扫描 `Token`，遇到 `STRING` 或者其它类型就知道这是在进行类型申明，`func` 就表示是函数申明。就这样一直扫描直到程序结束。
2. **自下而上** 这种是与上一种方式相反的，它先构造子树，然后再组装成一颗完整的树。

go 语言进行语法分析使用的是**自下而上**的方式来构造 `AST`，下面我们就来看一下 go 语言通过 `Token` 构造的这颗树是什么样子。

![img](https://xiaomi-info.github.io/2019/11/13/golang-compiler-principle/go-byq-5.png)

这其中有意思的地方我全部用文字标注出来了。你会发现其实每一个 `AST` 树的节点都与一个 `Token` 实际位置相对应。

这颗树构造后，我们可以看到不同的类型是由对应的结构体来进行表示的。这里如果有语法、词法错误是不会被解析出来的。因为到目前为止说白了都是进行的字符串处理。

### 语义分析

编译器里边都把语法分析后的阶段叫做 **语义分析**，而 go 的这个阶段叫 **类型检查**；但是我看了以下 go 自己的文档，其实做的事情没有太大差别，我们还是按照主流规范来写这个过程。

那么**语义分析/类型检查**究竟要做些什么呢？

`AST` 生成后，语义分析将使用它作为输入，并且的有一些相关的操作也会直接在这颗树上进行改写。

首先就是 `Golang` 文档中提到的会进行**类型检查**，还有**类型推断**，查看类型是否匹配，是否进行隐式转化（go 没有隐式转化）。

 [golang compile](https://github.com/golang/go/tree/master/src/cmd/compile)

> 生成 `AST` 之后是类型检查（也就是这里说的语义分析），第一步是进行名称检查和类型推断，签定每个对象所属的标识符，以及每个表达式具有什么类型。类型检查也还有一些其它的检查要做，像“声明未使用”以及确定函数是否中止。

> `AST` 也会进行转换，有些节点根据类型信息进行精简，比如从算术加法节点类型中拆分出字符串加法。其它一些例子像 `dead code` 的消除，函数调用内联和逃逸分析。

这里多说一句，我们常常在 debug 代码的时候，需要禁止内联，其实就是操作的这个阶段。

```shell
# 编译的时候禁止内联
go build -gcflags '-N -l'
```

`-N` 禁止编译优化
`-l` 禁止内联,禁止内联也可以一定程度上减小可执行程序大小

经过语义分析之后，就可以说明我们的代码结构、语法都是没有问题的。所以编译器前端主要就是解析出编译器后端可以处理的正确的 `AST` 结构。

机器只能够理解二进制并运行，所以编译器后端的任务简单来说就是怎么把 `AST` 翻译成机器码。

### 中间码生成

既然已经拿到 `AST`，机器运行需要的又是二进制。为什么不直接翻译成二进制呢？其实到目前为止从技术上来说已经完全没有问题了。

但是，我们有各种各样的操作系统，有不同的 CPU 类型，每一种的位数可能不同；寄存器能够使用的指令也不同，像是复杂指令集与精简指令集等；在进行各个平台的兼容之前，我们还需要替换一些底层函数，比如我们使用 `make` 来初始化 `slice`，此时会根据传入的类型替换为：`makeslice64` 或者 `makeslice`。当然还有像 `painc`、`channel` 等等函数的替换也会在中间码生成过程中进行替换。

这一部分的替换操作可以在[这里查看](https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/builtin/runtime.go)：

```url
https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/builtin/runtime.go
```

中间码存在的另外一个价值是提升后端编译的重用，比如我们定义好了一套中间码应该是长什么样子，那么后端机器码生成就是相对固定的。**每一种语言只需要完成自己的编译器前端工作即可**。这也是大家可以看到现在开发一门新语言速度比较快的原因。**编译是绝大部分都可以重复使用的**。

而且为了接下来的优化工作，中间代码存在具有非凡的意义。因为有那么多的平台，如果有中间码我们可以把一些共性的优化都放到这里。

中间码也是有多种格式的，像 `Golang` 使用的就是 SSA 特性的中间码 `IR`，这种形式的中间码，最重要的一个特性就是最在使用变量之前总是定义变量，并且每个变量只分配一次。

### 代码优化

在 go 的编译文档中，我并没找到独立的一步进行代码的优化。不过根据我们上面的分析，可以看到其实代码优化过程遍布编译器的每一个阶段。大家都会力所能及的做些事情。

通常我们除了用高效代码替换低效的之外，还有如下的一些处理：

- 并行性，充分利用现在多核计算机的特性
- 流水线，cpu 有时候在处理 a 指令的时候，还能同时处理 b 指令
- 指令的选择，为了让 cpu 完成某些操作，需要使用指令，但是不同的指令效率有非常大的差别，这里会进行指令优化
- 利用寄存器与高速缓存，我们都知道 cpu 从寄存器取是最快的，从高速缓存取次之。这里会进行充分的利用

### 机器码生成

经过优化后的中间代码，首先会在这个阶段被转化为汇编代码（Plan9），而汇编语言仅仅是机器码的文本表示，机器还不能真的去执行它。所以这个阶段会调用汇编器，汇编器会根据我们在执行编译时设置的架构，调用对应代码来生成目标机器码。

这里比有意思的是，`Golang` 总说自己的汇编器是跨平台的。其实他也是写了多分代码来翻译最终的机器码。因为在入口的时候他会根据我们所设置的 `GOARCH=xxx` 参数来进行初始化处理，然后最终调用对应架构编写的特定方法来生成机器码。这种上层逻辑一致，底层逻辑不一致的处理方式非常通用，非常值得我们学习。我们简单来一下这个处理。

首先看入口函数 `cmd/compile/main.go:main()`

```go
var archInits = map[string]func(*gc.Arch){
    "386":      x86.Init,
    "amd64":    amd64.Init,
    "amd64p32": amd64.Init,
    "arm":      arm.Init,
    "arm64":    arm64.Init,
    "mips":     mips.Init,
    "mipsle":   mips.Init,
    "mips64":   mips64.Init,
    "mips64le": mips64.Init,
    "ppc64":    ppc64.Init,
    "ppc64le":  ppc64.Init,
    "s390x":    s390x.Init,
    "wasm":     wasm.Init,
}

func main() {
    // 从上面的map根据参数选择对应架构的处理
    archInit, ok := archInits[objabi.GOARCH]
    if !ok {
        ......
    }
    // 把对应cpu架构的对应传到内部去
    gc.Main(archInit)
}
```

然后在 `cmd/internal/obj/plist.go` 中调用对应架构的方法进行处理

```go
func Flushplist(ctxt *Link, plist *Plist, newprog ProgAlloc, myimportpath string) {
    ... ...
    for _, s := range text {
        mkfwd(s)
        linkpatch(ctxt, s, newprog)
        // 对应架构的方法进行自己的机器码翻译
        ctxt.Arch.Preprocess(ctxt, s, newprog)
        ctxt.Arch.Assemble(ctxt, s, newprog)

        linkpcln(ctxt, s)
        ctxt.populateDWARF(plist.Curfn, s, myimportpath)
    }
}
```

整个过程下来，可以看到编译器后端有很多工作需要做的，你需要对某一个指令集、cpu 的架构了解，才能正确的进行翻译机器码。同时不能仅仅是正确，一个语言的效率是高还是低，也在很大程度上取决于编译器后端的优化。




## 编译子命令

### go run

编译并马上运行 Go 程序，它可接收一个或多个文件参数。但只接收 main 包下的文件作为参数，如果不是 main 包下的文件，则会出错。

在执行 go run 命令后，所编译的二进制文件最终存放在一个临时目录里。可以通过 -n 或 -x 参数进行查看。这两个参数的作用是打印编译过程中的所有执行命令，-n 参数不会继续执行编译后的二进制文件，而 -x 参数会继续执行编译后的二进制文件。

编译器执行了绝大部分编译相关的工作，过程如下：

![06tX5j.png](https://s1.ax1x.com/2020/10/10/06tX5j.png)

- 创建编译依赖所需的临时目录。Go 编译器会设置一个临时环境变量 WORK，用于在此工作区编译应用程序，执行编译后的二进制文件，其默认值为系统的临时文件目录路径。可以通过设置 GOTMPDIR 来调整其执行目录。
- 编译和生成编译所需要的依赖。该阶段将会编译和生成标准库中的依赖（如 flag.a、log.a、net/http等）、应用程序中的外部依赖（如 gin-gonic/gin 等），以及应用程序自身的代码，然后生成、链接对应归档文件（.a 文件）和编译配置文件。
- 创建并进入编译二进制文件所需的临时目录。即创建 exe 目录。
- 生成可执行文件。这里主要用到的是 link 工具，该工具读取依赖文件的 Go 归档文件或对象及其依赖项，最终将它们组合为可执行的二进制文件。

![06tOaQ.png](https://s1.ax1x.com/2020/10/10/06tOaQ.png)

- 执行可执行文件。到先前指定的目录 $WORK/b001/exe/main 下执行生成的二进制文件。

在执行 go run 命令后，除非设置了-work 参数，否则会在应用程序结束时自动删除该目录下的相关临时文件。

### go build

编译指定的源文件、软件包及其依赖项，但它不会运行编译后的二进制文件。在该目录下会生成了一个与当前目录名一致的可执行的二进制文件。

从本质上讲，go build 命令和 go run 命令的编译执行过程相差不多，唯一不同的是，go build 命令会生成并执行编译好的二进制文件，将其重命名为当前目录名，并立刻删除编译时生成的临时目录。而在归档文件（.a文件）上，go build 命令和 go run 命令的执行结果是一样的，都是对所需的源码文件进行编译。

### go install

是编译并安装源文件、软件包。“安装”看起来有些迷惑人，但实际上 go install 与 go build、go run 命令在功能上相差不多，最大的区别是 go install 命令会**将编译后的相关文件（如可执行的二进制文件、归档文件等）安装到指定的目录中**。

go install 命令在编译后，会**将生成的二进制文件移到 bin 目录下**，其文件名称为 go modules 的项目名，而非目录名。

当设置了环境变量 `$GOBIN` 时，会将生成的二进制文件移到`$GOBIN`下。另外，如果禁用了 go modules，那么将安装到 `$GOPATH/pkg/$GOOS_$GOARCH` 下。

## 编译参数

![06txGn.png](https://s1.ax1x.com/2020/10/10/06txGn.png)

## 交叉编译

交叉编译指通过编译器在某个系统下编译另外一个系统的可执行二进制文件，即目标计算架构的标识与当前运行环境的目标计算架构的标识不同，或者是所构建环境的目标操作系统的标识与当前运行环境的目标操作系统的标识不同。

### 常用参数

![06tvPs.png](https://s1.ax1x.com/2020/10/10/06tvPs.png)

### 进行交叉编译

```
set GOOS=linux
set CGO_ENABLED=0
go build -a -o cross .
```

### 编译缓存

在 Go 语言中，编译实际上是存在缓存机制的，它一般存储在特定的目录下：

```
go env GOCACHE
```

编译缓存是有一定意义的，并且目前还支持增量编译。这时又引申出一个新的问题，那就是如何界定是否有变更，编译器是否需要重新变更，是否根据文件的时间戳来进行对比呢？

实际上，在 Go 语言早期曾使用过时间戳的方式，但这是有问题的，因为文件的修改时间变更了，并不代表它的文件内容与先前的内容不同，即有可能是改了某个东西，然后又改回去了，因此基于时间戳是不正确的。

### 缩小编译文件大小

在默认情况下，gc 工具链中的链接器创建静态链接的二进制文件。因此，所有 Go 二进制文件都包含 Go  运行时的信息、支持动态类型检查，以及在异常抛出时堆栈跟踪所必需的运行时的类型信息（文件名/行号）。

在 Linux 上，使用 gcc 静态编译并静态链接的一个简单的 C 语言编写的 hello world 程序约为 750KB，而一个等效的 Go 程序使用的 fmt.Printf 的大小为几 MB，但是它包括更强大的运行时支持，以及类型和调试信息，因此两者实际上并不完全等效。

最简单的方法是去掉 DWARF 调试信息和符号表信息，执行命令如下：

```
go build -ldflags="-w -s"
```

![06NCrT.png](https://s1.ax1x.com/2020/10/10/06NCrT.png)

upx 工具对可执行文件进行压缩：

```
upx xxx.exe
```

### 编译信息写入

联合使用 go build 命令和 -ldflags 命令，即可在构建时将动态信息设置到二进制文件中。

```go
var version string

func main() {
    fmt.Printf("version: %s\n", version)
}
```

执行以下编译命令：

```
go build -ldflags "-X main.version=1.0.0"
./xxx
```
