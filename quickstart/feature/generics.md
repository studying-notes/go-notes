---
date: 2022-05-02T14:33:12+08:00
author: "Rustle Karl"  # 作者

title: "泛型 generics"  # 文章标题
url:  "posts/go/quickstart/feature/generics"  # 设置网页永久链接
tags: [ "Go", "generics" ]  # 标签
categories: [ "Go 学习笔记" ]  # 分类

toc: true  # 目录
draft: true  # 草稿
---

> https://go.dev/blog/intro-generics

泛型是一种可以独立于所使用的特定类型编写代码的方式。函数和类型可以用一组类型中的任何一种来编写。

泛型为语言添加了三个新的重要内容：

- 函数和类型的类型参数。 
- 将接口类型定义为类型集，包括没有方法的类型。
- 类型推断，允许在调用函数时在许多情况下省略类型参数。

## 类型参数

现在允许函数和类型具有类型参数。类型参数列表看起来像一个普通的参数列表，除了它使用方括号而不是圆括号。

为了展示它是如何工作的，让我们从浮点值的基本非泛型 Min 函数开始：

```go
func Min(x, y float64) float64 {
    if x < y {
        return x
    }
    return y
}
```

我们可以通过添加类型参数列表来使这个函数通用——使其适用于不同的类型。在这个例子中，我们添加了一个带有单个类型参数 T 的类型参数列表，并将 float64 的使用替换为 T。

```go
import "golang.org/x/exp/constraints"

func GMin[T constraints.Ordered](x, y T) T {
    if x < y {
        return x
    }
    return y
}
```

现在可以通过编写类似的调用来使用类型参数调用此函数

```go
x := GMin[int](2, 3)
```

向 GMin 提供类型参数（在本例中为 int）称为实例化。实例化分两步进行。首先，编译器在泛型函数或类型中用所有类型参数替换它们各自的类型参数。其次，编译器验证每个类型参数是否满足各自的约束。我们很快就会明白这意味着什么，但如果第二步失败，实例化就会失败，程序就会无效。

成功实例化后，我们有一个可以像任何其他函数一样调用的非泛型函数。例如，在类似的代码中

```go
fmin := GMin[float64]
m := fmin(2.71, 3.14)
```

实例化 GMin[float64] 产生了我们原来的浮点 Min 函数，我们可以在函数调用中使用它。

类型参数也可以与类型一起使用。

```go
type Tree[T interface{}] struct {
    left, right *Tree[T]
    value       T
}

func (t *Tree[T]) Lookup(x T) *Tree[T] { ... }

var stringTree Tree[string]
```

这里泛型类型 Tree 存储类型参数 T 的值。泛型类型可以有方法，如本例中的 Lookup。为了使用泛型类型，它必须被实例化； Tree[string] 是使用类型参数 string 实例化 Tree 的示例。

## 类型集

让我们更深入地了解可用于实例化类型参数的类型参数。 

普通函数对每个值参数都有一个类型；该类型定义了一组值。例如，如果我们在上面的非泛型函数 Min 中有一个 float64 类型，则允许的参数值集是可以由 float64 类型表示的浮点值集。 

同样，类型参数列表对每个类型参数都有一个类型。因为类型参数本身就是一种类型，所以类型参数的类型定义了类型集。这种元类型称为类型约束。

在通用 GMin 中，类型约束是从约束包中导入的。 Ordered 约束描述了具有可排序值的所有类型的集合，或者换句话说，与 < 运算符（或 <= 、 > 等）进行比较。该约束确保只有具有可排序值的类型才能传递给 GMin。这也意味着在 GMin 函数体中，该类型参数的值可以用于与 < 运算符进行比较。

在 Go 中，类型约束必须是接口。即接口类型可以作为值类型，也可以作为元类型。接口定义了方法，因此显然我们可以表达需要某些方法存在的类型约束。但是 constraints.Ordered 也是一个接口类型，< 操作符不是一个方法。 为了完成这项工作，我们以一种新的方式看待接口。

直到最近，Go 规范才说接口定义了一个方法集，大致就是接口中枚举的方法集。实现所有这些方法的任何类型都实现了该接口。

但另一种看法是，接口定义了一组类型，即实现这些方法的类型。从这个角度来看，作为接口类型集元素的任何类型都实现了该接口。

这两个观点导致相同的结果：对于每组方法，我们可以想象实现这些方法的相应类型集，即接口定义的类型集。 

但是，就我们的目的而言，类型集视图比方法集视图具有优势：我们可以显式地将类型添加到集合中，从而以新的方式控制类型集。 

我们扩展了接口类型的语法以使其工作。例如， interface{ int|string|bool } 定义了包含 int、string 和 bool 类型的类型集。

另一种说法是该接口仅由 int、string 或 bool 满足。

现在让我们看一下 contraints.Ordered 的实际定义：

```go
type Ordered interface {
    Integer|Float|~string
}
```

该声明表明 Ordered 接口是所有整数、浮点和字符串类型的集合。竖线表示类型的联合（或本例中的类型集）。 Integer 和 Float 是在约束包中类似定义的接口类型。请注意，Ordered 接口没有定义任何方法。 

对于类型约束，我们通常不关心特定类型，例如字符串；我们对所有字符串类型都感兴趣。这就是 `~` 标记的用途。表达式 `~string` 表示底层类型为字符串的所有类型的集合。这包括类型字符串本身以及使用定义声明的所有类型，例如类型 MyString 字符串。 

当然，我们仍然希望在接口中指定方法，并且我们希望向后兼容。在 Go 1.18 中，接口可以像以前一样包含方法和嵌入式接口，但它也可以嵌入非接口类型、联合和底层类型集。 当用作类型约束时，接口定义的类型集准确地指定了允许作为相应类型参数的类型参数的类型。在泛型函数体内，如果操作数的类型是带有约束 C 的类型参数 P，则在 C 的类型集中的所有类型都允许的情况下允许操作（这里目前有一些实现限制，但普通代码是不太可能遇到他们）。 

用作约束的接口可以被赋予名称（例如 Ordered），或者它们可以是内联在类型参数列表中的文字接口。例如：

```go
[S interface{~[]E}, E interface{}]
```

这里 S 必须是一个切片类型，其元素类型可以是任何类型。 因为这是一种常见的情况，所以对于处于约束位置的接口，可以省略封闭的 interface{}，我们可以简单地写：

```go
[S ~[]E, E interface{}]
```

```go

```
