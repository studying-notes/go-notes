---
date: 2020-11-25T14:57:48+08:00  # 创建日期
author: "Rustle Karl"  # 作者

# 文章
title: "项目日志系统规范"  # 文章标题
url:  "posts/gin/project/log"  # 设置网页链接，默认使用文件名
tags: [ "gin", "go" ]  # 自定义标签
series: [ "Gin 学习笔记"]  # 文章主题/文章系列
categories: [ "学习笔记"]  # 文章分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

## 日志系统实践

目前我写的项目一般将日志分成四种类型，分别是：

- 业务日志：接口层和服务层直接业务功能日志
- 访问日志：用户 HTTP 请求和响应日志
- 恢复/异常日志：发生了无法处理的 panic 时的日志
- 系统日志：记录系统信息，比如启动服务、启动参数等，以及服务层与用户行为、业务不产生直接关联的信息，比如服务层中另外提供了 TCP 服务请求或控制某个终端的功能、请求其他服务的 HTTP 客户端等的日志

可以打印的层级为接口层和服务层，数据库层不作打印，原因有二，一是容易重复打印相同内容，二是 GORM 框架的日志输出已经相当不错。

对于打印什么日志、设置什么级别，还在纠结中。

====== 以下是正文 ======

## 日志有什么用？

- **打印调试**：即可以用日志来记录变量或者某一段逻辑。记录程序运行的流程，即程序运行了哪些代码，方便排查逻辑问题。
- **问题定位**：程序出异常或者出故障时快速的定位问题，方便后期解决问题。因为线上生产环境无法 debug，在测试环境去模拟一套生产环境，费时费力。所以依靠日志记录的信息定位问题。
- **用户行为日志**：记录用户的操作行为，用于大数据分析，比如监控、风控、推荐等等。这种日志，一般是给其他团队分析使用，而且可能是多个团队，因此一般会有一定的格式要求，开发者应该按照这个格式来记录，便于其他团队的使用。当然，要记录哪些行为、操作，一般也是约定好的，因此，开发者主要是执行的角色。
- **根因分析**：即在关键地方记录日志。方便在和各个终端定位问题时，别人说时你的程序问题，你可以理直气壮的拿出你的日志说，看，我这里运行了，状态也是对的。这样，对方就会乖乖去定位他的代码，而不是互相推脱。

## 什么时候记录日志？

- **系统初始化**：系统或者服务的**启动参数**。核心模块或者组件初始化过程中往往依赖一些关键配置，根据参数不同会提供不一样的服务。务必在这里记录 INFO 日志，**打印出参数以及启动完成态服务表述**。
- **编程语言提示异常**：如今各类主流的编程语言都包括异常机制，业务相关的流行框架有完整的异常模块。这类捕获的异常是系统告知开发人员需要加以关注的，是质量非常高的报错。应当适当记录日志，根据实际结合业务的情况使用 WARN 或者 ERROR 级别。
- **业务流程预期不符**：除开平台以及编程语言异常之外，项目代码中**结果与期望不符时**也是日志场景之一，简单来说所有流程分支都可以加入考虑。取决于开发人员判断能否容忍情形发生。常见的合适场景包括外部参数不正确，数据处理问题导致返回码不在合理范围内等等。
- **系统核心角色，组件关键动作**：系统中核心角色触发的业务动作是需要多加关注的，是衡量系统正常运行的重要指标，建议记录 INFO 级别日志，比如电商系统用户从登录到下单的整个流程；微服务各服务节点交互；核心数据表增删改；核心组件运行等等，如果日志频度高或者打印量特别大，可以提炼关键点 INFO 记录，其余酌情考虑 DEBUG 级别。
- **第三方服务远程调用**：微服务架构体系中有一个重要的点就是**第三方永远不可信**，对于**第三方服务远程调用建议打印请求和响应的参数**，方便在和各个终端定位问题，不会因为第三方服务日志的缺失变得手足无措。

## 当前日志文件命名

不建议以日志级别分别写入文件，个人认为错误的定位必须有上下文。

```
<应用名>-<功能名>.log
```

### 访问日志文件

请求和该请求响应的全部信息记录。

```text
example-server-access.log
```

### 服务日志文件

系统或者服务的**启动参数**、业务流程中的信息记录。

```text
example-server-service.log
```

### 恢复日志文件名

服务发生了必须中断 `panic` 的错误信息记录。

```text
example-server-recovery.log
```

### 子服务日志文件名

服务还依赖了可独立的另一个服务时，另一个服务必须有独立的日志。

```text
example-server-service.log
```

## 已经滚入历史的日志文件名

```
<应用名>-<功能名>.yyyy-MM-dd-hh.<滚动号>.log
```

```text
example-server-access.2019-12-01-10.1.log
```

## 参数占位格式

使用参数化形式 {} 占位，[] 进行参数隔离，这样的好处是可读性更高，而且只有真正准备打印的时候才会处理参数。

```java
// 正确示例，必须使用参数化信息的方式
log.debug("order is paying with userId:[{}] and orderId : [{}]",userId, orderId);

// 错误示例，不要进行字符串拼接，那样会产生很多 String 对象，占用空间，影响性能
log.debug("order is paying with userId: " + userId + " and orderId: " + orderId);
```

## 日志的基本格式

### 日志时间

作为日志产生的日期和时间，这个数据非常重要，一般精确到毫秒。

```text
yyyy-MM-dd HH:mm:ss.SSS
```

### 隐私数据的处理

TODO 隐私审查模块

### 日志级别

日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。

- DEBUG：DEUBG 级别的主要输出调试性质的内容，该级别日志主要用于在开发、测试阶段输出。该级别的日志应尽可能地详尽，开发人员可以将**各类详细信息**记录到 DEBUG 里，起到调试的作用，包括**参数信息**，**调试细节信息**，**返回值信息**等等，便于在开发、测试阶段出现问题或者异常时，对其进行分析。
- INFO：INFO 级别的主要记录系统关键信息，旨在保留系统正常工作期间关键运行指标，开发人员可以将**初始化系统配置**、**业务状态变化信息**，或者**用户业务流程中的核心处理**记录到 INFO 日志中，方便日常运维工作以及错误回溯时上下文场景复现。建议在项目完成后，在测试环境将日志级别调成 INFO，然后通过 INFO 级别的信息看看是否能了解这个应用的运用情况，如果出现问题后是否这些日志能否提供有用的排查问题的信息。
- WARN：WARN 级别的主要**输出警告性质的内容**，这些内容是**可以预知且是有规划**的，比如，某个方法**入参为空**或者**该参数的值不满足运行该方法的条件**时。在 WARN 级别的时应输出较为详尽的信息，以便于事后对日志进行分析。
- ERROR：ERROR 级别主要针对于一些**不可预知的信息**，诸如：错误、异常等，比如，在 catch 块中抓获的网络通信、数据库连接等异常，若异常对系统的整个流程影响不大，可以使用 WARN 级别日志输出。在输出 ERROR 级别的日志时，尽量多地输出方法入参数、方法执行过程中产生的对象等数据，在带有错误、异常对象的数据时，需要将该对象一并输出。

**DEBUG / INFO 的选择**

DEBUG 级别比 INFO 低，包含调试时更详细的了解系统运行状态的东西，比如变量的值等等，都可以输出到 DEBUG 日志里。INFO 是在线日志默认的输出级别，反馈系统的当前状态给最终用户看的。输出的信息，应该对最终用户具有实际意义的。从功能角度上说，**INFO 输出的信息可以看作是软件产品的一部分**，所以需要谨慎对待，**不可随便输出**。如果这条日志会被频繁打印或者大部分时间对于纠错起不到作用，就应当考虑下调为 DEBUG 级别。

- 由于 DEBUG 日志打印量远大于 INFO，出于前文日志性能的考虑，如果代码为核心代码，执行频率非常高，务必推敲日志设计是否合理，是否需要下调为 DEBUG 级别日志。
- 注意日志的可读性，不妨在写完代码 review 这条日志是否通顺，能否提供真正有意义的信息。
- 日志输出是多线程公用的，如果有另外一个线程正在输出日志，上面的记录就会被打断，最终显示输出和预想的就会不一致。

**WARN / ERROR 的选择**

当方法或者功能处理过程中产生不符合预期结果或者有框架报错时可以考虑使用，常见问题处理方法包括：

- 增加判断处理逻辑，尝试本地解决：增加逻辑判断吞掉报警永远是最优选择抛出异常，交给上层逻辑解决
- 抛出异常，交给上层逻辑解决
- 记录日志，报警提醒
- 使用返回码包装错误做返回

一般来说，WARN 级别不会短信报警，ERROR 级别则会短信报警甚至电话报警，ERROR 级别的日志意味着系统中发生了非常严重的问题，必须有人马上处理，比如数据库不可用，系统的关键业务流程走不下去等等。错误的使用反而带来严重的后果，不区分问题的重要程度，只要有问题就 error 记录下来，其实这样是非常不负责任的，因为对于成熟的系统，都会有一套完整的报错机制，那这个错误信息什么时候需要发出来，很多都是依据单位时间内 ERROR 日志的数量来确定的。

**强调 ERROR 报警**

- ERROR 级别的日志打印通常伴随报警通知。ERROR 的报出应该伴随着业务功能受损，即上面提到的系统中发生了非常严重的问题，必须有人马上处理。

ERROR 日志目标

- 给处理者直接准确的信息：ERROR 信息形成自身闭环。

问题定位：

- 发生了什么问题，哪些功能受到影响
- 获取帮助信息：直接帮助信息或帮助信息的存储位置
- 通过报警知道解决方案或者找何人解决

### opentracing 标识

在分布式应用中，用户的一个请求会调用若干个服务完成，这些服务可能还是嵌套调用的，因此完成一个请求的日志并不在一个应用的日志文件，而是分散在不同服务器上不同应用节点的日志文件中。该标识是为了串联一个请求在整个系统中的调用日志。

- 唯一字符串（trace id）
- 调用层级（span id）

通过搜索 trace id 就可以查到这个 trace id 标识的请求在整个系统中流转（处理）过程中产生的所有日志。

### biz 标识

在业务开发中，我们的日志都是和业务相关联的，有时候是需要根据用户或者业务做聚类的，因此一次请求如果可以通过某项标识做聚类的时候，可以将聚类标识打印到日志中。

- 用户标识（user id）
- 业务标识（biz id）

### 日志记录器名称

日志记录器名称一般使用类名，日志文件中可以输出简单的类名即可，看实际情况是否需要使用包名和行号等信息。主要用于看到日志后到哪个类中去找这个日志输出，便于定位问题所在。

### 异常堆栈

异常堆栈一般会出现在 ERROR 或者 WARN 级别的日志中，异常堆栈含有方法调用链的系统，以及异常产生的根源。异常堆栈的日志属于上一行日志的，在日志收集时需要将其划至上一行中。
