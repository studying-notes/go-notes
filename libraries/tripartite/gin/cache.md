---
date: 2020-11-30T21:30:24+08:00  # 创建日期
author: "Rustle Karl"  # 作者

# 文章
title: "进程内缓存"  # 文章标题
# description: "文章描述"
url:  "posts/gin/project/cache"  # 设置网页永久链接
tags: [ "go", "gin"]  # 标签
series: [ "Gin 学习笔记"]  # 文章主题/文章系列
categories: [ "学习笔记"]  # 文章分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

## 缓存简介

对于Web系统而言，缓存无处不在。

- 分布式缓存：当出现大流量、高并发时，数据库常常会成为瓶颈，这时一般会引入分布式缓存来缓解数据库的压力。常见的有 Redis、Memcached。
- 进程内缓存（本地缓存）：由于分布式缓存会有网络开销，所以出现了进程内缓存，指的是应用中的缓存组件。这种缓存的优点是应用和缓存在同一进程内，省去了网络开销，节省了内网带宽，同时响应时延会更低。缺点是多个应用无法共享缓存，且难以保持进程内缓存的一致性。
- 语言级的缓存：有的动态语言会有语言级的缓存，比如 PHP 的 opcode 缓存，就是语言级的优化。
- CDN 缓存、HTTP 缓存、Web 浏览器缓存等。

## 进程内缓存的应用场景

- 只读数据，可以考虑在进程启动时加载到内存，比如配置信息。
- 高并发，比如在秒杀时，并发量极高，这时可以考虑使用进程内缓存。
- 在一定程度上允许分布式不同节点的数据不一致。例如，一些计数场景或运营场景，页面对数据一致性要求较低，这时可以考虑使用进程内页面缓存。
- 对性能要求极高，进程外缓存的网络开销无法满足需求，这时可以考虑使用进程内缓存。这也是 Go 中 BigCache 缓存库出现的原因之一。

## 缓存淘汰算法

常用的缓存淘汰算法有：

- FIFO（First In First Out，先进先出）算法。
- LFU（Least Frequently Used，最少使用）算法。
- LRU（Least Recently Used，最近最少使用）算法。
