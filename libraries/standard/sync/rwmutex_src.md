---
date: 2020-11-15T13:56:20+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "Go 读写互斥锁实现原理"  # 文章标题
url:  "posts/go/libraries/standard/sync/rwmutex_src"  # 设置网页永久链接
tags: [ "Go", "rwmutex-src" ]  # 标签
categories: [ "Go 学习笔记" ]  # 分类

toc: true  # 目录
draft: true  # 草稿
---

- [前言](#前言)
- [读写锁数据结构](#读写锁数据结构)
	- [类型定义](#类型定义)
	- [接口定义](#接口定义)
	- [Lock() 实现逻辑](#lock-实现逻辑)
	- [Unlock()实现逻辑](#unlock实现逻辑)
	- [RLock()实现逻辑](#rlock实现逻辑)
	- [RUnlock()实现逻辑](#runlock实现逻辑)
- [场景分析](#场景分析)
	- [写操作是如何阻止写操作的](#写操作是如何阻止写操作的)
	- [写操作是如何阻止读操作的](#写操作是如何阻止读操作的)
	- [读操作是如何阻止写操作的](#读操作是如何阻止写操作的)
	- [为什么写锁定不会被饿死](#为什么写锁定不会被饿死)

## 前言

读写锁 RWMutex，完整的表述应该是读写互斥锁，可以说是 Mutex 的一个改进版，在某些场景下可以发挥更加灵活的控制能力，比如：读取数据频率远远大于写数据频率的场景。

例如，程序中写操作少而读操作多，简单的说，如果执行过程是 1 次写然后 N 次读的话，使用 Mutex，这个过程将是串行的，因为即便 N 次读操作互相之间并不影响，但也都需要持有 Mutex 后才可以操作。如果使用读写锁，多个读操作可以同时持有锁，并发能力将大大提升。

实现读写锁需要解决如下几个问题：

1. 写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞
2. 写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞
3. 读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞
4. 读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁

下面我们将按照这个思路，即读写锁如何解决这些问题的，来分析读写锁的实现。

读写锁基于 Mutex 实现，实现源码非常简单和简洁，又有一定的技巧在里面。

## 读写锁数据结构

### 类型定义

源码包 `src/sync/rwmutex.go:RWMutex` 定义了读写锁数据结构：

```go
type RWMutex struct {
	w           Mutex  //用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此
	writerSem   uint32 //写阻塞等待的信号量，最后一个读者释放锁时会释放信号量
	readerSem   uint32 //读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量
	readerCount int32  //记录读者个数
	readerWait  int32  //记录写阻塞时读者个数
}
```

由以上数据结构可见，读写锁内部仍有一个互斥锁，用于将两个写操作隔离开来，其他的几个都用于隔离读操作和写操作。

下面我们简单看下 RWMutex 提供的 4 个接口，后面再根据使用场景具体分析这几个成员是如何配合工作的。

### 接口定义

RWMutex 提供 4 个简单的接口来提供服务：

- RLock()：读锁定
- RUnlock()：解除读锁定
- Lock(): 写锁定，与 Mutex 完全一致
- Unlock()：解除写锁定，与 Mutex 完全一致

### Lock() 实现逻辑

写锁定操作需要做两件事：

- 获取互斥锁
- 阻塞等待所有读操作结束（如果有的话）

所以 `func (rw *RWMutex) Lock()` 接口实现流程如下图所示：

![](../../../assets/images/libraries/standard/sync/rwmutex_src/b9214cae374145f2.png)

### Unlock()实现逻辑

解除写锁定要做两件事：

- 唤醒因读锁定而被阻塞的协程（如果有的话）
- 解除互斥锁

所以 `func (rw *RWMutex) Unlock()` 接口实现流程如下图所示：

![](../../../assets/images/libraries/standard/sync/rwmutex_src/4c38ac2a2ec064cb.png)

### RLock()实现逻辑

读锁定需要做两件事：

- 增加读操作计数，即 readerCount++
- 阻塞等待写操作结束 ( 如果有的话 )

所以 `func (rw *RWMutex) RLock()` 接口实现流程如下图所示：

![](../../../assets/images/libraries/standard/sync/rwmutex_src/5caa9f4c8bacdf6e.png)

### RUnlock()实现逻辑

解除读锁定需要做两件事：

- 减少读操作计数，即 readerCount--
- 唤醒等待写操作的协程（如果有的话）

所以 `func (rw *RWMutex) RUnlock()` 接口实现流程如下图所示：

![](../../../assets/images/libraries/standard/sync/rwmutex_src/9a3741800c350a0f.png)

即便有协程阻塞等待写操作，并不是所有的解除读锁定操作都会唤醒该协程，而是**最后一个解除读锁定的协程才会释放信号量将该协程唤醒**，因为只有**当所有读操作的协程释放锁后才可以唤醒协程**。

## 场景分析

上面我们简单看了下 4 个接口实现原理，接下来我们看一下是如何解决前面提到的几个问题的。

### 写操作是如何阻止写操作的

读写锁包含一个互斥锁 (Mutex)，写锁定必须要先获取该互斥锁，如果互斥锁已被协程 A 获取（或者协程 A 在阻塞等待读结束），意味着协程 A 获取了互斥锁，那么协程 B 只能阻塞等待该互斥锁。

所以，写操作依赖互斥锁阻止其他的写操作。

### 写操作是如何阻止读操作的

这个是读写锁实现中最精华的技巧。

我们知道 `RWMutex.readerCount` 是个整型值，用于表示读者数量，**不考虑写操作的情况下，每次读锁定将该值 +1，每次解除读锁定将该值 -1**，所以 readerCount 取值为 [0, N]，N 为读者个数，**实际上最大可支持 2 ^ 30 个并发读者**。

当写锁定进行时，会先将 readerCount 减去 2 ^ 30，从而 **readerCount 变成了负值**，此时再有读锁定到来时检测到 readerCount 为负值，便**知道有写操作在进行，只好阻塞等待**。而**真实的读操作个数并不会丢失，只需要将 readerCount 加上 2 ^ 30 即可获得**。

所以，**写操作将 readerCount 变成负值来阻止读操作的**。

### 读操作是如何阻止写操作的

读锁定会先将 RWMutext.readerCount 加 1，此时写操作到来时发现读者数量不为 0，会阻塞等待所有读操作结束。

所以，读操作通过 readerCount 来将来阻止写操作的。

### 为什么写锁定不会被饿死

我们知道，**写操作要等待读操作结束后才可以获得锁**，**写操作等待期间可能还有新的读操作持续到来**，如果写操作等待所有读操作结束，很可能被饿死。然而，通过 RWMutex.readerWait 可完美解决这个问题。

写操作到来时，会把 RWMutex.readerCount 值拷贝到 RWMutex.readerWait 中，**用于标记排在写操作前面的读者个数**。

前面的读操作结束后，除了会递减 RWMutex.readerCount，还会递减 RWMutex.readerWait 值，当 RWMutex.readerWait 值变为 0 时唤醒写操作。

RWMutex.readerWait 由读操作赋值，由写操作减少值，这个过程中其他读操作不能改变该值。

所以，写操作就相当于把一段连续的读操作划分成两部分，前面的读操作结束后唤醒写操作，写操作结束后唤醒后面的读操作。如下图所示：

![](../../../assets/images/libraries/standard/sync/rwmutex_src/c1f41dfe651d5628.png)

```go

```
