---
date: 2020-11-15T13:49:18+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "Go 并发同步互斥锁实现原理"  # 文章标题
url:  "posts/go/libraries/standard/sync/mutex_src"  # 设置网页永久链接
tags: [ "Go", "mutex-src" ]  # 标签
categories: [ "Go 学习笔记" ]  # 分类

toc: true  # 目录
draft: true  # 草稿
---

## 前言

互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此 Go 语言提供了非常简单易用的 Mutex，Mutex 为一结构体类型，对外暴露两个方法 Lock() 和 Unlock() 分别用于加锁和解锁。

## 数据结构

### 结构体

源码包 `src/sync/mutex.go:Mutex` 定义了互斥锁的数据结构：

```go
type Mutex struct {
	state int32
	sema  uint32
}
```

- Mutex.state 表示互斥锁的状态，比如是否被锁定等。
- Mutex.sema 表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。

我们看到 Mutex.state 是 32 位的整型变量，内部实现时把该变量分成四份，用于记录 Mutex 的四种状态。

下图展示 Mutex 的内存布局：

![](https://dd-static.jd.com/ddimg/jfs/t1/104604/18/32574/9060/63144ac4E732349bf/c2ae3396a8efcf90.png)

- Locked : 表示该 Mutex 是否已被锁定，0：没有锁定 1：已被锁定。
- Woken : 表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。
- Starving：表示该 Mutex 是否处于饥饿状态，0：没有饥饿 1：饥饿状态，说明有协程阻塞了超过 1ms。
- Waiter : 表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。

协程之间抢锁实际上是抢给 Locked 赋值的权利，能给 Locked 域置 1，就说明抢锁成功。抢不到的话就阻塞等待 Mutex.sema 信号量，一旦持有锁的协程解锁，等待的协程会依次被唤醒。

Woken 和 Starving 主要用于控制协程间的抢锁过程，后面再进行了解。

### 方法

Mutex 对外提供两个方法，实际上也只有这两个方法：

- Lock() : 加锁方法
- Unlock(): 解锁方法

下面我们分析一下加锁和解锁的过程，加锁分成功和失败两种情况，成功的话直接获取锁，失败后当前协程被阻塞，同样，解锁时根据是否有阻塞协程也有两种处理。

## 加解锁过程

### 简单加锁

假定当前只有一个协程在加锁，没有其他协程干扰，那么过程如下图所示：

![](https://dd-static.jd.com/ddimg/jfs/t1/194695/23/28202/13421/63144b1fEaff2c579/017c4cd5988955c2.png)

加锁过程会去判断 Locked 标志位是否为 0，如果是 0 则把 Locked 位置 1，代表加锁成功。从上图可见，加锁成功后，只是 Locked 位置 1，其他状态位没发生变化。

### 加锁被阻塞

假定加锁时，锁已被其他协程占用了，此时加锁过程如下图所示：

![](https://dd-static.jd.com/ddimg/jfs/t1/220038/22/20982/20608/63144b42E1ffff0e3/eae070629013984e.png)

从上图可看到，当协程B对一个已被占用的锁再次加锁时，Waiter计数器增加了1，此时协程B将被阻塞，直到Locked值变为0后才会被唤醒。

### 简单解锁

假定解锁时，没有其他协程阻塞，此时解锁过程如下图所示：

![](https://dd-static.jd.com/ddimg/jfs/t1/35813/34/17366/19751/63144b5aE42ca2916/a82254fc34c33dff.png)

由于没有其他协程阻塞等待加锁，所以此时解锁时只需要把 Locked 位置为 0 即可，不需要释放信号量。

### 解锁并唤醒协程

假定解锁时，有 1 个或多个协程阻塞，此时解锁过程如下图所示：

![](https://dd-static.jd.com/ddimg/jfs/t1/107290/23/33112/19751/63144b6aE778547e3/39ca8986063f268e.png)

协程 A 解锁过程分为两个步骤，一是把 Locked 位置 0，二是查看到 Waiter>0，所以释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程 B 把 Locked 位置 1，于是协程 B 获得锁。

## 自旋过程

加锁时，如果当前 Locked 位为 1，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续的探测 Locked 位是否变为 0，这个过程即为自旋过程。

自旋时间很短，但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次阻塞。

自旋的好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免协程的切换。

### 什么是自旋

自旋对应于 CPU 的" PAUSE "指令，CPU 对该指令什么都不做，相当于 CPU 空转，对程序而言相当于 sleep 了一小段时间，时间非常短，当前实现是 30 个时钟周期。

自旋过程中会持续探测 Locked 是否变为 0，连续两次探测间隔就是执行这些 PAUSE 指令，它不同于 sleep，不需要将协程转为睡眠状态。

### 自旋条件

加锁时程序会自动判断是否可以自旋，无限制的自旋将会给 CPU 带来巨大压力，所以判断是否可以自旋就很重要了。

自旋必须满足以下所有条件：

- 自旋次数要足够小，通常为 4，即自旋最多 4 次
- CPU 核数要大于 1，否则自旋没有意义，因为此时不可能有其他协程释放锁
- 协程调度机制中的 Process 数量要大于 1，比如使用 GOMAXPROCS() 将处理器设置为 1 就不能启用自旋
- 协程调度机制中的可运行队列必须为空，否则会延迟协程调度

可见，自旋的条件是很苛刻的，总而言之就是不忙的时候才会启用自旋。

### 自旋的优势

自旋的优势是更充分的利用 CPU，尽量避免协程切换。因为当前申请加锁的协程拥有 CPU，如果经过短时间的自旋可以获得锁，当前协程可以继续运行，不必进入阻塞状态。

### 自旋的问题

如果自旋过程中获得锁，那么之前被阻塞的协程将无法获得锁，如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的进程将很难获得锁，从而进入饥饿状态。

为了避免协程长时间无法获取锁，自 1.8 版本以来增加了一个状态，即 Mutex 的 Starving 状态。这个状态下不会自旋，一旦有协程释放锁，那么一定会唤醒一个协程并成功加锁。

## 模式

前面分析加锁和解锁过程中只关注了 Waiter 和 Locked 位的变化，现在我们看一下 Starving 位的作用。

每个 Mutex 都有两个模式，称为 Normal 和 Starving。下面分别说明这两个模式。

### normal 模式

默认情况下，Mutex 的模式为 normal。

该模式下，协程如果加锁不成功不会立即转入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程，尝试抢锁。

### starvation 模式

自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们知道释放锁时如果发现有阻塞等待的协程，还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到 CPU 后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过 1ms 的话，会将 Mutex 标记为"饥饿"模式，然后再阻塞。

处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减 1。

## Woken 状态

Woken 状态用于加锁和解锁过程的通信，举个例子，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把 Woken 标记为 1，用于通知解锁协程不必释放信号量了，好比在说：你只管解锁好了，不必释放信号量，我马上就拿到锁了。

## 为什么重复解锁要 panic

可能你会想，为什么 Go 不能实现得更健壮些，多次执行 Unlock() 也不要 panic ？

仔细想想 Unlock 的逻辑就可以理解，这实际上很难做到。Unlock 过程分为将 Locked 置为 0，然后判断 Waiter 值，如果值 >0，则释放信号量。

如果多次 Unlock()，那么可能每次都释放一个信号量，这样会唤醒多个协程，多个协程唤醒后会继续在 Lock() 的逻辑里抢锁，势必会增加 Lock() 实现的复杂度，也会引起不必要的协程切换。

### 加锁和解锁应该成对出现

加锁和解锁最好出现在**同一个层次的代码块中**，比如同一个函数。

**重复解锁会引起 panic**，应避免这种操作的可能性。

```go

```
