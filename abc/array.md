---
date: 2020-07-26T21:06:02+08:00  # 创建日期
author: "Rustle Karl"  # 作者

# 文章
title: "Go 语言数组"  # 文章标题
description: "纸上得来终觉浅，学到过知识点分分钟忘得一干二净，今后无论学什么，都做好笔记吧。"
url:  "posts/go/abc/array"  # 设置网页永久链接
tags: [ "go", "array" ]  # 标签
series: [ "Go 学习笔记"]  # 系列
categories: [ "学习笔记"]  # 分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

## 底层数据结构

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。**数组的长度是数组类型的组成部分**。因为数组的长度是数组类型的一部分，**不同长度或不同类型的数据组成的数组都是不同的类型**，所以在 Go 语言中很少直接使用数组（不同长度的数组因为类型不同无法直接赋值）。和数组对应的类型是切片，切片是可以动态增长和收缩的序列，切片的功能也更加灵活，但是要理解切片的工作原理还是要先理解数组。

数组的定义方式：

```go
var a [3]int                    // 定义长度为3的int型数组，元素为 [0 0 0]
var b = [...]int{1, 2, 3}       // 定义长度为3的int型数组，元素为 [1, 2, 3]
var c = [...]int{2: 3, 1: 2}    // 定义长度为3的int型数组，元素为 [0, 2, 3]
var d = [...]int{1, 2, 4: 5, 6} // 定义长度为6的int型数组，元素为 [1, 2, 0, 0, 5, 6]
```

- 第一种方式是定义一个数组变量的最基本的方式，数组的长度明确指定，数组中的每个元素都以零值初始化。
- 第二种方式是定义数组，可以在定义的时候顺序指定全部元素的初始化值，数组的长度根据初始化元素的数目自动计算。
- 第三种方式是以索引的方式来初始化数组的元素，因此元素的初始化值出现顺序比较随意。这种初始化方式和 `map[int]Type` 类型的初始化语法类似。**数组的长度以出现的最大的索引为准**，没有明确初始化的元素依然用零值初始化。
- 第四种方式是混合了第二种和第三种的初始化方式，前面两个元素采用顺序初始化，第三个和第四个元素采用零值初始化，第五个元素通过索引初始化，最后一个元素跟在前面的第五个元素之后采用顺序初始化。

## 内存布局

数组的内存结构比较简单。`[4]int{2,3,5,7}` 数组值对应的内存结构如下：

![06toxP.png](https://s1.ax1x.com/2020/10/10/06toxP.png)

Go 语言中数组是值语义。**一个数组变量即表示整个数组**，它并不是隐式地指向第一个元素的指针（例如C语言的数组），而是一个完整的值。**当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组**。如果数组较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。

```go
func main() {
	var a = [...]int{1, 2, 3} // a 是一个数组
	var b = &a                // b 是指向数组的指针

	fmt.Println(a[0], a[1]) // 打印数组的前两个元素
	fmt.Println(b[0], b[1]) // 通过数组指针访问数组元素的方式和通过数组类似

	for i, v := range b { // 通过数组指针迭代数组的元素
		fmt.Println(i, v)
	}
}
```

其中 b 是指向数组 a 的指针，但是通过 b 访问数组中元素的写法和 a 是类似的。还可以通过 `for range` 来迭代数组指针指向的数组元素。其实数组指针类型除类型和数组不同之外，通过数组指针操作数组的方式和通过数组本身的操作类似，而且**数组指针赋值时只会复制一个指针**。但是数组指针类型依然不够灵活，因为数组的长度是数组类型的组成部分，**指向不同长度数组的数组指针类型也是完全不同的**。

可以将数组看作一个特殊的结构体，结构的字段名对应数组的索引，同时结构体成员的数目是固定的。内置函数 `len()` 可以用于计算数组的长度，`cap()` 函数可以用于计算数组的容量。不过对数组类型来说，`len()` 和 `cap()` 函数返回的结果始终是一样的，都是对应数组类型的长度。

## 遍历数组

遍历数组几种方式：

```go
func main() {
	var a = [...]int{1, 2, 3}

	for i := range a {
		fmt.Printf("a[%d]: %d\n", i, a[i])
	}
	for i, v := range a {
		fmt.Printf("a[%d]: %d\n", i, v)
	}
	for i := 0; i < len(a); i++ {
		fmt.Printf("a[%d]: %d\n", i, a[i])
	}
}
```

用 `for range` 方式迭代的性能可能会更好一些，因为这种迭代可以保证不会出现数组越界的情形，每轮迭代对数组元素的访问时可以省去对下标越界的判断。

用 `for range` 方式迭代，还可以忽略迭代时的下标：

```go
func main() {
	var times [5][0]int
	for range times {
		fmt.Println("hello")
	}

	for range make([][]int, 5){
		fmt.Println("world")
	}
}
```

其中 times 对应一个 `[5][0]int` 类型的数组，虽然第一维数组有长度，但是数组的元素 `[0]int` 大小是 0，因此整个数组占用的内存大小依然是 0。**不用付出额外的内存代价**，我们就通过 `for range` 方式实现 `times` 次快速迭代。

## 类型数组

数组不仅可以定义数值数组，还可以定义字符串数组、结构体数组、函数数组、接口数组、通道数组等：

```go
func main() {
	// 字符串数组
	var s1 = [2]string{"hello", "world"}
	var s2 = [...]string{"你好", "世界"}
	var s3 = [...]string{1: "世界", 0: "你好"}

	// 结构体数组
	var line1 [2]image.Point
	var line2 = [...]image.Point{image.Point{X: 0, Y: 0}, image.Point{X: 1, Y: 1}}
	var line3 = [...]image.Point{{0, 0}, {1, 1}}

	// 函数数组
	var decoder1 [2]func(io.Reader) (image.Image, error)
	var decoder2 = [...]func(io.Reader) (image.Image, error){
		png.Decode,
		jpeg.Decode,
	}

	// 接口数组
	var unknown1 [2]interface{}
	var unknown2 = [...]interface{}{123, "你好"}

	// 通道数组
	var chanList = [2]chan int{}
}
```

我们还可以定义一个空的数组：

```go
var d [0]int       // 定义一个长度为0的数组
var e = [0]int{}   // 定义一个长度为0的数组
var f = [...]int{} // 定义一个长度为0的数组
```

长度为0的数组（空数组）在内存中并不占用空间。空数组虽然很少直接使用，但是可以用于**强调某种特有类型的操作时避免分配额外的内存空间**，例如用于通道的同步操作：

```go
func main() {
	c1 := make(chan [0]int)
	go func() {
		fmt.Println("c1")
		c1 <- [0]int{}
	}()
	<-c1
}
```

在这里，我们并不关心通道中传输数据的真实类型，其中通道接收和发送操作只是用于消息的同步。对于这种场景，我们用空数组作为通道类型可以减少通道元素赋值时的开销。当然，**一般更倾向于用无类型的匿名结构体代替空数组**：

```go
func main() {
	c2 := make(chan struct{})
	go func() {
		fmt.Println("c2")
		c2 <- struct{}{} // struct{} 部分是类型，{} 表示对应的结构体值
	}()
	<-c2
}
```

## 打印数组详细信息

我们可以用 `fmt.Printf()` 函数提供的` %T` 或 `%#v` 谓词语法来打印数组的类型和详细信息：

```go
func main() {
	var a = [...]int{1, 2, 3}
	// `%T` 输出一个值的数据类型
	fmt.Printf("%T\n", a) // [3]int
	// `%#v` 格式化输出将输出一个值的 Go 语法表示方式
	fmt.Printf("%#v\n", a) // [3]int{1, 2, 3}
}
```

### 数组转切片

```go
array = [3]int{1,2,3}
slice = array[:]
```

## 二维数组

```go
var twoArrs [3][5]int = [...][5]int{{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}}
```

二维数组中的第二个 [] 中的数值 5 并没有省略为...，否则会出现 use of [...] array outside of array literal 错误提示。

能否把 [...]type 也去除掉呢？答案是不行！但可以把数组定义简写为：

```go
strArr := [...]string{"a", "b", "c", "d", "e", "f"}
byteArr := [...]byte{32, 23, 42, 26, 21}
floatArr := [...]float64{3.1415, 2.6728, 1.4114}
twoArrs := [...][5]int{{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}}
```

```go

```

```go

```
