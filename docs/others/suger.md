---
date: 2020-11-16T21:08:21+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "Go 语法糖"  # 文章标题
url:  "posts/go/docs/others/suger"  # 设置网页永久链接
tags: [ "go", "语法糖" ]  # 标签
series: [ "Go 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

- [前言](#前言)
- [题目](#题目)
  - [题目一](#题目一)
  - [题目二](#题目二)
  - [题目三](#题目三)
- [参考答案](#参考答案)
  - [题目一](#题目一-1)
  - [题目二](#题目二-1)
  - [题目三](#题目三-1)
- [前言](#前言-1)
- [规则](#规则)
  - [规则一： 多变量赋值可能会重新声明](#规则一-多变量赋值可能会重新声明)
  - [规则二：不能用于函数外部](#规则二不能用于函数外部)
- [变量作用域问题](#变量作用域问题)

## 前言

相信你已经大量使用过简短变量声明，比如像下面这样：

```go
i := 0
j, k := 1, 2
```

` := ` 用来声明变量并赋值，不管是个人项目、公司项目和开源项目都会大量应用。根据我做过的小范围调查结果看，有多年 Go 开发经验的工程师也不能很好的回答 ` := ` 相关的问题。

在开始讨论 ` := ` 前，请试着回答一下这些题目，再根据参考答案对照一下，或许会有令你惊讶的发现。

## 题目

### 题目一

问：下面代码输出什么？

```go
func fun1() {
    i := 0
    i, j := 1, 2
    fmt.Printf("i = %d, j = %d\n", i, j)
}
```

### 题目二

问：下面代码为什么不能通过编译？

```go
func fun2(i int) {
    i := 0
    fmt.Println(i)
}
```

### 题目三

问：下面代码输出什么？

```go
func fun3() {
    i, j := 0, 0
    if true {
        j, k := 1, 1
        fmt.Printf("j = %d, k = %d\n", j, k)
    }
    fmt.Printf("i = %d, j = %d\n", i, j)
}
```

## 参考答案

### 题目一

程序输出如下：

```go
i = 1, j = 2
```

再进一步想一下，前一个语句中已经声明了 i, 为什么还可以再次声明呢？

### 题目二

不能通过编译原因是形参已经声明了变量 i，使用`:=`再次声明是不允许的。

再进一步想一下，编译时会报 "no new variable on left side of := " 错误，该怎么理解？

### 题目三

程序输出如下：

```go
j = 1, k = 1
i = 0, j = 0
```

这里要注意的是，block `if` 中声明的 j，与上面的 j 属于不同的作用域。

## 前言

虽然简短变量声明这个语法糖用起来很方便，但有时也会给你一个意外也可能带你掉入陷阱。

我曾因滥用这个 ` := ` 语法糖，发生过一次故障，所以才认真研究了一下它的原理和规则，大家可以作为参考。

## 规则

### 规则一： 多变量赋值可能会重新声明

我们知道使用 ` := ` 一次可以声明多个变量，像下面这样：

```go
field1, offset := nextField(str, 0)
```

上面代码定义了两个变量，并用函数返回值进行赋值。

如果这两个变量中的一个再次出现在 ` := ` 左侧就会重新声明。像下面这样：

```go
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)
```

offset 被重新声明。

重新声明并没有什么问题，它并没有引入新的变量，只是把变量的值改变了，但要明白，这是 Go 提供的一个语法糖。

- 当 ` := ` 左侧存在新变量时（如 field2），那么已声明的变量（如 offset）则会被重新声明，不会有其他额外副作用。
- 当 ` := ` 左侧没有新变量是不允许的，编译会提示 `no new variable on left side of := `。

我们所说的重新声明不会引入问题要满足一个前提，变量声明要在同一个作用域中出现。如果出现在不同的作用域，那很可能就创建了新的同名变量，同一函数不同作用域的同名变量往往不是预期做法，很容易引入缺陷。关于作用域的这个问题，我们在本节后面介绍。

### 规则二：不能用于函数外部

简短变量场景只能用于函数中，使用 ` := ` 来声明和初始化全局变量是行不通的。

比如，像下面这样：

```go
package sugar
import fmt

rule := "Short variable declarations" // syntax error: non-declaration statement outside function body
```

这里的编译错误提示 `syntax error : non-declaration statement outside function body`，表示非声明语句不能出现在函数外部。可以理解成 ` := ` 实际上会拆分成两个语句，即声明和赋值。赋值语句不能出现在函数外部的。

## 变量作用域问题

几乎所有的工程师都了解变量作用域，但是由于 ` := ` 使用过于频繁的话，还是有可能掉进陷阱里。

下面代码源自真实项目，但为了描述方便，也为了避免信息安全风险，简化如下：

```go
func Redeclare() {
    field, err:= nextField()   // 1号err

    if field == 1{
        field, err:= nextField()     //2号err
        newField, err := nextField() //  3号err
        ...
    }
    ...
}
```

注意上面声明的三个 err 变量。

2 号 err 与 1 号 err 不属于同一个作用域，` := ` 声明了新的变量，所以 2 号 err 与 1 号 err 属于两个变量。

2 号 err 与 3 号 err 属于同一个作用域，` := ` 重新声明了 err 但没创建新的变量，所以 2 号 err 与 3 号 err 是同一个变量。

如果误把 2 号 err 与 1 号 err 混淆，就很容易产生意想不到的错误。
