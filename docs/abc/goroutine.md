---
date: 2020-11-15T14:20:51+08:00  # 创建日期
author: "Rustle Karl"  # 作者

# 文章
title: "Go 协程及其调度机制"  # 文章标题
# description: "文章描述"
url:  "posts/go/abc/goroutine2"  # 设置网页永久链接
tags: [ "go", "goroutine" ]  # 标签
series: [ "Go 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

# 前言

Goroutine 调度是一个很复杂的机制，尽管 Go 源码中提供了大量的注释，但对其原理没有一个好的理解的情况下去读源码收获不会很大。下面尝试用简单的语言描述一下 Goroutine 调度机制，在此基础上再去研读源码效果可能更好一些。

## 线程池的缺陷

我们知道，在高并发应用中频繁创建线程会造成不必要的开销，所以有了线程池。线程池中预先保存一定数量的线程，而新任务将不再以创建线程的方式去执行，而是将任务发布到任务队列，线程池中的线程不断地从任务队列中取出任务并执行，可以有效的减少线程创建和销毁所带来的开销。

下图展示一个典型的线程池：

[![Dif2I1.png](https://s3.ax1x.com/2020/11/15/Dif2I1.png)](https://imgchr.com/i/Dif2I1)

为了方便下面的叙述，我们把任务队列中的每一个任务称作 G，而 G 往往代表一个函数。线程池中的 worker 线程不断地从任务队列中取出任务并执行。而 worker 线程的调度则交给操作系统进行调度。

如果 worker 线程执行的 G 任务中发生系统调用，则操作系统会将该线程置为阻塞状态，也意味着该线程在怠工，也意味着消费任务队列的 worker 线程变少了，也就是说线程池消费任务队列的能力变弱了。

如果任务队列中的大部分任务都会进行系统调用，则会让这种状态恶化，大部分 worker 线程进入阻塞状态，从而任务队列中的任务产生堆积。

解决这个问题的一个思路就是重新审视线程池中线程的数量，增加线程池中线程数量可以一定程度上提高消费能力，但随着线程数量增多，由于过多线程争抢 CPU，消费能力会有上限，甚至出现消费能力下降。 如下图所示：

[![DifhRK.png](https://s3.ax1x.com/2020/11/15/DifhRK.png)](https://imgchr.com/i/DifhRK)

## Goroutine 调度器

线程数过多，意味着操作系统会不断地切换线程，频繁的上下文切换就成了性能瓶颈。Go 提供一种机制，可以在线程中自己实现调度，上下文切换更轻量，从而达到了线程数少，而并发数并不少的效果。而线程中调度的就是 Goroutine.

早期 Go 版本，比如 1.9.2 版本的源码注释中有关于调度器的解释。Goroutine 调度器的工作就是把“ ready-to-run ”的 goroutine 分发到线程中。

Goroutine主要概念如下：

- G（Goroutine）: 即 Go 协程，每个 go 关键字都会创建一个协程。
- M（Machine）： 工作线程，在 Go 中称为 Machine。
- P(Processor): 处理器（ Go 中定义的一个摡念，不是指 CPU ），包含运行 Go 代码的必要资源，也有调度 goroutine 的能力。

M 必须拥有 P 才可以执行 G 中的代码，P 含有一个包含多个 G 的队列，P 可以调度 G 交由 M 执行。其关系如下图所示：

[![DifIMD.png](https://s3.ax1x.com/2020/11/15/DifIMD.png)](https://imgchr.com/i/DifIMD)

图中 M 是交给操作系统调度的线程，M 持有一个 P，P 将 G 调度进 M 中执行。P 同时还维护着一个包含 G 的队列（图中灰色部分），可以按照一定的策略将 G 调度到 M 中执行。

P 的个数在程序启动时决定，默认情况下等同于 CPU 的核数，由于 M 必须持有一个 P 才可以运行 Go 代码，所以同时运行的 M 个数，也即线程数一般等同于 CPU 的个数，以达到尽可能的使用 CPU 而又不至于产生过多的线程切换开销。

程序中可以使用 `runtime.GOMAXPROCS()` 设置 P 的个数，在某些 IO 密集型的场景下可以在一定程度上提高性能。

## Goroutine 调度策略

### 队列轮转

上图中可见每个 P 维护着一个包含 G 的队列，不考虑 G 进入系统调用或 IO 操作的情况下，P 周期性的将 G 调度到 M 中执行，执行一小段时间，将上下文保存下来，然后将 G 放到队列尾部，然后从队列中重新取出一个 G 进行调度。

除了每个 P 维护的 G 队列以外，还有一个全局的队列，每个 P 会周期性地查看全局队列中是否有 G 待运行并将其调度到 M 中执行，全局队列中 G 的来源，主要有从系统调用中恢复的 G。之所以 P 会周期性地查看全局队列，也是为了防止全局队列中的 G 被饿死。

### 系统调用

上面说到 P 的个数默认等于 CPU 核数，每个 M 必须持有一个 P 才可以执行 G，一般情况下 M 的个数会略大于 P 的个数，这多出来的 M 将会在 G 产生系统调用时发挥作用。类似线程池，Go 也提供一个 M 的池子，需要时从池子中获取，用完放回池子，不够用时就再创建一个。

当 M 运行的某个 G 产生系统调用时，如下图所示：

[![DifXJP.png](https://s3.ax1x.com/2020/11/15/DifXJP.png)](https://imgchr.com/i/DifXJP)

如图所示，当 G0 即将进入系统调用时，M0 将释放 P，进而某个空闲的 M1 获取 P，继续执行 P 队列中剩下的 G。而 M0 由于陷入系统调用而进被阻塞，M1 接替 M0 的工作，只要 P 不空闲，就可以保证充分利用 CPU。

M1 的来源有可能是 M 的缓存池，也可能是新建的。当 G0 系统调用结束后，根据 M0 是否能获取到 P，将会将 G0 做不同的处理：

1. 如果有空闲的 P，则获取一个 P，继续执行 G0。
2. 如果没有空闲的 P，则将 G0 放入全局队列，等待被其他的 P 调度。然后 M0 将进入缓存池睡眠。

### 工作量窃取

多个 P 中维护的 G 队列有可能是不均衡的，比如下图：

[![Dihkiq.png](https://s3.ax1x.com/2020/11/15/Dihkiq.png)](https://imgchr.com/i/Dihkiq)

竖线左侧中右边的 P 已经将 G 全部执行完，然后去查询全局队列，全局队列中也没有 G，而另一个 M 中除了正在运行的 G 外，队列中还有 3 个 G 待运行。此时，空闲的 P 会将其他 P 中的 G 偷取一部分过来，一般每次偷取一半。偷取完如右图所示。

### GOMAXPROCS 设置对性能的影响

一般来讲，程序运行时就将 GOMAXPROCS 大小设置为 CPU 核数，可让 Go 程序充分利用 CPU。在某些 IO 密集型的应用里，这个值可能并不意味着性能最好。

理论上当某个 Goroutine 进入系统调用时，会有一个新的 M 被启用或创建，继续占满 CPU。

但由于 Go 调度器检测到 M 被阻塞是有一定延迟的，也即旧的 M 被阻塞和新的 M 得到运行之间是有一定间隔的，所以在 IO 密集型应用中不妨把 GOMAXPROCS 设置的大一些，或许会有好的效果。
