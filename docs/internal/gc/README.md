---
date: 2022-10-10T21:45:20+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "垃圾回收初探"  # 文章标题
url:  "posts/go/docs/internal/gc/README"  # 设置网页永久链接
tags: [ "Go", "readme" ]  # 标签
categories: [ "Go 学习笔记" ]  # 分类

toc: true  # 目录
draft: true  # 草稿
---

在计算机科学中，垃圾回收（Garbage Collection，GC）是自动内存管理的一种形式，通常由垃圾收集器收集并适时回收或重用不再被对象占用的内存。

垃圾回收作为内存管理的一部分，包含 3 个重要的功能：**分配和管理新对象**、**识别正在使用的对象**、**清除不再使用的对象**。

## 为什么需要垃圾回收

### 减少错误和复杂性

传统的没有垃圾回收功能的语言，例如 C、C++，需要手动分配、释放内存。不管是内存泄漏还是野指针都是让开发者非常头疼的问题。虽然垃圾回收不保证完全不产生内存泄漏，但是其提供了重要的保障，即不再被引用的对象最终将被收集。这种设定同样避免了悬空指针、多次释放等手动管理内存时会出现的问题。具有垃圾回收功能的语言屏蔽了内存管理的复杂性，开发者可以更好地关注核心的业务逻辑。

### 解耦

现代软件工程设计的核心思想之一是以模块化的方式进行组合，而模块与模块之间只提供少量的接口进行交互。减少模块之间的耦合意味着一个模块的行为不依赖另一个模块的实现。**当两个模块同时维护一个内存时，释放内存将会变得非常小心。**手动分配的问题在于难以在本地模块内做出全局的决定，而具有垃圾回收功能的语言将垃圾收集的工作托管给了具有全局视野的运行时代码。开发者编写的业务模块将真正实现解耦，从而有利于开发、调试，并开发出更大规模的、高并发的项目。

垃圾回收并不是在任何场景下都适用的，因为垃圾回收带来了额外的成本，需要保存内存的状态信息（例如是否使用、是否包含指针）并扫描内存，很多时候还需要中断整个程序来处理垃圾回收。因此，垃圾回收对于要求极致的速度时和内存要求极小的场景（例如嵌入式、系统级程序）并不适用，却是开发大规模、分布式、微服务集群的极佳选择。

内存管理与垃圾回收都属于 Go 语言最复杂的模块。永远不可能有最好的垃圾回收算法，因为每个应用程序的硬件条件、工作负载、性能要求都是不同的，理论上，可以为单独的应用程序设计最佳的内存分配方案。通用的具有垃圾回收的编程语言会提供通用的垃圾回收算法，并且每一种语言侧重的垃圾回收目标不尽相同。垃圾回收的常见指标包括程序暂停时间、空间开销、回收的及时性等，根据设计目标的侧重点不同有不同的垃圾回收算法。

## 垃圾回收的 5 种经典算法

### 标记-清扫

标记 - 清扫（ Mark-Sweep）算法是历史最悠久的垃圾回收算法，其最早可以追溯到 1960 年，由约翰·麦卡锡（John · McCarthy）提出，用于 LISP 语言的自动内存管理。

标记 - 清扫算法顾名思义分为两个主要阶段，第 1 阶段是扫描并标记当前活着的对象，第 2 阶段是清扫没有被标记的垃圾对象。因此，标记 - 清扫算法是一种间接的垃圾回收算法，它**不直接查找垃圾对象，而是通过活着的对象推断出垃圾对象**。

扫描一般从栈上的根对象开始，只要对象引用了其他堆对象，就会一直向下扫描，因此可以采取深度优先搜索或者广度优先搜索的方式进行扫描。

在扫描阶段，为了有效管理扫描对象的状态，可以通过颜色对对象的状态进行抽象，比较经典的抽象方式是 Dijkstra 于 1976 年左右提出的三色抽象，如图 19-2 所示，其通过将对象标记为黑色（已经被扫描）、灰色（暂时还没有被扫描，扫描之后会转换为黑色）、白色（暂时还没有被扫描，可能有垃圾对象，如果被灰色对象扫描引用并扫描到，则会标记为灰色）来对对象进行区分。

![](../../../assets/images/docs/internal/gc/README/图19-2%20三色抽象.png)

有些垃圾回收算法将对象进行了更多颜色的抽象，后面会看到，在 Go 语言中，使用了经典的三色标记算法。

标记 - 清扫算法的主要缺点在于**可能产生内存碎片或空洞**，这会导致新对象分配失败。想象一下，如果中间的区域已经被分配，留下了两端各 20MB 空闲的内存空间，那么该程序将由于没有连续的区域而不能够分配 30MB 的内存，如图 19-3 所示。

![](../../../assets/images/docs/internal/gc/README/图19-3%20内存空洞.png)

### 标记-压缩

标记 - 压缩（ Mark-Compact）算法通过将分散的、活着的对象移动到更紧密的空间来解决内存碎片问题。标记 - 压缩算法分为标记与压缩两个阶段。如图 19-4 所示，与标记过程和标记 - 清扫算法类似，在压缩阶段，需要扫描活着的对象并将其压缩到空闲的区域，这可以保证压缩后的空间更紧凑，从而解决内存碎片问题。同时，压缩后的空间能以更快的速度查找到空闲的内存区域（在已经使用内存的后方）。

![](../../../assets/images/docs/internal/gc/README/图19-4%20标记-压缩算法.png)

标记-压缩算法的缺点在于内存对象在内存的位置是随机的，这常常会**破坏缓存的局部性**，并且时常需要一些额外的空间来标记当前对象已经移动到了其他地方。在压缩阶段，如果 B 对象发生了转移，那么必须更新所有引用了 B 对象的 A 对象的指针，这无疑增加了实现的复杂性。

### 半空间复制

半空间复制（Semispace Copy）是一种用空间换时间的算法。经典的半空间复制算法只能**使用一半的内存空间，保留另一半的内存空间用于快速压缩内存**，因此得名。

半空间复制的压缩性消除了内存碎片问题，同时，其压缩时间比标记 - 压缩算法更短。半空间复制不分阶段，在扫描根对象时就可以直接压缩，每个扫描到的对象都会从 fromspace 的空间复制到 tospace 的空间。因此，一旦扫描完成，就得到了一个压缩后的副本。

![](../../../assets/images/docs/internal/gc/README/图19-5%20半空间复制算法.png)

### 引用计数

一种直接简单的识别垃圾对象的算法是引用计数（Reference Counting），如图 19-6 所示，每个对象都包含一个引用计数，每当其他对象引用了此对象时，引用计数就会增加。反之，取消引用后，引用计数就会减少。一旦引用计数为 0，就表明该对象为垃圾对象，需要被回收。引用计数算法简单高效，在垃圾回收阶段不需要额外占用大量内存，即便垃圾回收系统的一部分出现异常，也能有一部分对象被正常回收。

但这种朴素的算法也有一些致命的缺点：一些没有破坏性的操作，如只读操作、循环迭代操作也需要更新引用计数，栈上的内存操作或寄存器操作更新引用计数是难以接受的。同时，**引用计数必须原子更新**，并发操作同一个对象会导致引用计数难以处理自引用的对象。

![](../../../assets/images/docs/internal/gc/README/图19-6%20引用计数算法.png)

### 分代回收

分代 GC 指将对象按照存活时间进行划分。这种算法的重要前提是：**死去的对象一般都是新创建不久的**，因此，没有必要反复地扫描旧对象，这大概率会加快垃圾回收的速度，提高处理能力和吞吐量，减少程序暂停的时间，如图 19-7 所示。但是分代 GC 也不是没有成本的，这种算法没有办法及时回收老一代的对象，并且需要额外开销引用和区分新老对象，特别是在有多代对象的时候。

![](../../../assets/images/docs/internal/gc/README/图19-7%20分代GC算法.png)

需要注意的是，上面每一种算法在实践中都有许多微妙的变化，例如分代 GC 可以不止有两代，而有多代；需要考虑如何定义老对象等。当这些策略混合起来使用，并且考虑到并发或并行的场景时，会更加复杂。

## Go 语言中的垃圾回收

Go 语言采用了并发三色标记算法进行垃圾回收。三色标记是最简单的垃圾回收算法，其实现也很简单。引用计数由于其固有的缺陷（必须原子操作）在并发时很少使用，不适合 Go 这样的高并发语言，值得探讨的是为什么不选择压缩 GC 与分代 GC。

### 为什么不选择压缩 GC

压缩算法的主要优势是减少碎片并且快速分配。Go 语言使用了现代内存分配算法 TCmalloc，虽然没有压缩算法那样极致，但它已经很好地解决了内存碎片的问题。并且，由于需要加锁，压缩算法并不适合在并发程序中使用。另外，在 Go 语言设计初期，由于时间紧迫，设计团队放弃了考虑更加复杂的压缩算法，转而使用了更简单的三色标记算法。

### 为什么不选择分代 GC

Go 语言并不是没有尝试过分代 GC。分代 GC 的主要假设是大部分变成垃圾的对象都是新创建的，但是由于编译器的优化，**Go 语言通过内存逃逸的机制将会继续使用的对象转移到了堆中，大部分生命周期很短的对象会在栈中分配**，这和其他使用分代 GC 的编程语言有显著的不同，减弱了使用分代 GC 的优势。同时，分代 GC 需要额外的写屏障来保护并发垃圾回收时对象的隔代性，会减慢 GC 的速度。因此，分代 GC 是被尝试过并抛弃的方案。

## Go 垃圾回收演进

Go 语言的垃圾回收算法叫作并发三色标记，Go 语言的垃圾回收算法经历了一系列的演进才有了现在的高性能。

### 单协程垃圾回收

![](../../../assets/images/docs/internal/gc/README/图19-8%20Go%201.0单协程垃圾回收.png)

图 19-8 为 Go 1.0 的单协程垃圾回收，**在垃圾回收开始阶段需要停止所有的用户协程**，并且在垃圾回收阶段只有一个协程执行垃圾回收。

### 多协程垃圾回收

在 Go 1.1 之后，**垃圾回收由多个协程并行执行**，大大加快了垃圾回收的速度，但是这个阶段仍然不允许用户协程执行，如图 19-9 所示。

![](../../../assets/images/docs/internal/gc/README/图19-9%20Go%201.1多协程垃圾回收.png)

### 并行垃圾回收

Go 1.5 对垃圾回收进行了重大更新，该版本**允许用户协程与后台的垃圾回收同时执行**，大大降低了用户协程暂停的时间（从 300ms 左右降低到 40ms 左右），如图 19-10 所示。

![](../../../assets/images/docs/internal/gc/README/图19-10%20Go%201.5并行垃圾回收.png)

### 引入混合写屏障技术

在 Go 1.5 发布半年后，Go 1.6 大幅度减少了在 STW（Stop The World）期间的任务，使得用户协程暂停的时间从 40ms 左右降到 5ms 左右。

Go 1.8 使用了**混合写屏障技术消除了栈重新扫描的时间**，将用户协程暂停的时间降低到 0.5ms 左右，如图 19-11 所示。

![](../../../assets/images/docs/internal/gc/README/图19-11%20Go%201.8引入混合写屏障技术.png)

## 深入垃圾回收全流程

[深入垃圾回收全流程](underlying_principle.md)

```go

```
