---
date: 2022-10-10T10:21:39+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "数据争用检查"  # 文章标题
url:  "posts/go/docs/internal/goroutine/race/README"  # 设置网页永久链接
tags: [ "Go", "readme" ]  # 标签
categories: [ "Go 学习笔记" ]  # 分类

toc: true  # 目录
draft: true  # 草稿
---

## 什么是数据争用

数据争用（data race）在 Go 语言中指两个协程同时访问相同的内存空间，并且至少有一个写操作的情况。这种情况常常是并发错误的根源，也是最难调试的并发错误之一。

下例中的两个协程共同访问了全局变量 count，乍看之下可能没有问题，但是该程序其实是有数据争用的，count 的结果也是不明确的。

```go
package main

var count = 0

func add() {
	count++
}

func main() {
	go add()
	go add()
}
```

count++ 操作看起来是一条指令，但是对 CPU 来说，需要先读取 count 的值，执行 +1 操作，再将 count 的值写回内存。

大部分人期望的操作可能如下：R ← 0 代表读取到 0，w → 1 代表写入 count 为 1 ；协程 1 写入数据 1 后，协程 2 再写入，count 最后的值为 2。

当两个协程并行时，情况开始变得复杂。协程 1 读取 count 的值，协程 2 也读取 count 的值，此时 count 的值为 0，两个协程都执行 +1 操作，最后写入 count 的值为 1，这样 count 的值就变成了 1。

这两种情况告诉我们，当两个协程发生数据争用时，结果是不可预测的，这会导致很多奇怪的错误。

## 数据争用检查

Go 1.1 后提供了强大的检查工具 race 来排查数据争用问题。race 可以使用在多个 Go 指令中，当检测器在程序中找到数据争用时，将打印报告。该报告包含发生 race 冲突的协程栈，以及此时正在运行的协程栈。

```
go test -race main.go
go run -race main.go
go build -race main.go
go install -race main.go
```

比如对上面的程序进行检查，会得到如下报告：

```
go run -race main.go
```

```
==================
WARNING: DATA RACE
Read at 0x000000578100 by goroutine 7:
  main.add()
      main.go:6 +0x29

Previous write at 0x000000578100 by goroutine 6:
  main.add()
      main.go:6 +0x44

Goroutine 7 (running) created at:
  main.main()
      main.go:11 +0x35

Goroutine 6 (finished) created at:
  main.main()
      main.go:10 +0x29
==================
Found 1 data race(s)
exit status 66
```

竞争检测的成本因程序而异，对于典型的程序，内存使用量可能增加 5～10 倍，执行时间会增加 2～20 倍。同时，竞争检测器为当前每个 defer 和 recover 语句额外分配 8 字节，在 Goroutine 退出前，这些额外分配的字节不会被回收。这意味着，如果有一个长期运行的 Goroutine 并定期有 defer 和 recover 调用，则程序内存的使用量可能无限增长。这些内存分配不会显示到 runtime.ReadMemStats 或 runtime/pprof 的输出中。

## 原理

race 工具借助了 ThreadSanitizer，ThreadSanitizer 是谷歌为了应对内部大量服务器端 C++ 代码的数据争用问题而开发的新一代工具，目前也被 Go 语言内部通过 CGO 的形式进行调用。

从之前的数据争用问题可以看出，当不同的协程访问同一块内存区域并且其中有一个写操作时，可能触发数据争用，也可能不触发。

如果对 count 的访问用锁进行保护，就不会触发数据争用，因为一个协程对 count 的访问必须等待另一个协程的锁释放后才能开始。

对 count 的访问可能出现两种情况。一种是协程 A 结束后，协程 B 继续执行。另一种是协程 B 结束后，协程 A 继续执行。但是 A、B 不可能同时访问 count 变量，这时 A、B 之间的关系叫作 happened-before，可以用符号→表示。如果 A 先发生，B 后发生，那么 A → B。

矢量时钟(Vector Clock)技术用来观察事件之间 happened-before 的顺序，该技术在分布式系统中使用广泛，用于检测和确定分布式系统中事件的因果关系，也可以用于数据争用的探测。在 Go 程序中，有 n 个协程就会有对应的 n 个逻辑时钟，而矢量时钟是所有这些逻辑时钟组成的数组，表示形式为 t = `<t1，…，tn>`。

![](../../../../assets/images/docs/internal/goroutine/race/README/图17-3%20矢量时钟技术.png)

以图 17-3 为例，来看一看矢量时钟技术。协程 GA 和 GB 初始化时都有一个逻辑时钟数组 `<0，0>`。为了说明方便，指定数组 `<0，0>` 中的第 1 个数字代表协程 GA，第 2 个数字代表协程 GB，每个特定的事件都会增加自己的逻辑时钟。例如，当协程 A 完成 count++ 操作时，实际上执行了两个事件，一个事件是读取 count 的内容，另一个事件是写入数据到 count 变量中。因此当协程 GA 结束操作时，其矢量时钟为 `<2，0>`。

![](../../../../assets/images/docs/internal/goroutine/race/README/图17-4%20矢量时钟查看happened-before顺序.png)

当加锁后，协程 B 能够观察到协程 A 已经释放了锁，其会更新内部对于协程 A 的逻辑时钟，并在后续的操作中，增加自己的逻辑时钟。因此，我们能够从矢量时钟的关系中看出是否有 happened-before 的关系。例如，图 17-4 中的 `<1，0>` 一定发生在 `<2，1>` 之前。

在 Go 语言中，每个协程在创建之初都会初始化矢量时钟，并在读取或写入事件时修改自己的逻辑时钟。

触发 race 事件主要有两种方式，一种方式是在 Go 语言运行时中大量注入触发事件，例如在数组、切片、map、通道访问时。

另外一种方式是依靠编译器自动插入。当加上 race 指令后，编译器会在可能发生数据争用的地方插入 race 相关的指令。

这些事件将触发逻辑时钟的更新，检查是否发生了数据争用。如果当前事件并没有数据争用，那么当前的事件会是一个最新的事件，这时会存储当前事件的信息以在下一次检查时使用。保存的信息包含了协程 ID、当前协程的逻辑时钟、接触的内存区域位于当前位置偏移量，以及是写操作还是读操作。注意，为了节约内存，保存的事件信息存储的不是向量时钟数组而是逻辑时钟。

![](../../../../assets/images/docs/internal/goroutine/race/README/图17-5%20通过逻辑时钟判断是否収生数据争用.png)

如图 17-5 所示，可以通过逻辑时钟判断是否发生数据争用。假设一开始协程 GA 先操作并写入 count 变量，那么在其保存的数据中，第 1 个变量为协程 GA 的 ID，第 2 个变量为当前协程的逻辑时钟 2，第 3 个变量为接触的内存区域，是当前位置向后 8 字节，最后的 1 代表写入操作。而另一边由于并发执行，当协程 GB 执行到读取 count 操作时，其向量时钟为 `<0，1>`，这时需要检查其是否与前一个写入操作发生了冲突。

根据以下 4 点判断是否发生冲突：

- 是否有一个操作是写操作
- 是否接触了同一片内存
- 是否是不同的协程
- 两个事件之间是否是 happened-before 关系

前 3 个条件都比较好判断，现在重点关注一下第 4 个判断条件。当前协程 GB 的向量时钟为 `<0，1>`，而协程 GA 只存储了逻辑时钟 2，可以看作 `<2，X>`。现在无法确定两个事件是 happened-before 关系，因为 X 可能是任意的，当 X>1 时，GA → GB ；当 X<1（例如 0）时，二者之间没有任何前后关系，因此发生了数据争用。

```go

```
